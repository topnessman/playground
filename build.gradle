/*
 * This build file was auto generated by running the Gradle 'init' task
 * by 'mier' at '19/06/17 9:55 PM' with Gradle 2.10
 *
 * This generated file contains a sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at https://docs.gradle.org/2.10/userguide/tutorial_java_projects.html
 */

// Apply the java plugin to add support for Java
apply plugin: 'java'


/************************ system variables ************************/
def env         = System.getenv()

def javaHome    = env["JAVA_HOME"]

//TODO: copy from CF Inference, need refactor later on
//determined based on the the version of the currently running JVM
def jreVersion  = {
    def envJreVersion = env["CFI_JRE_VERSION"];
    if(envJreVersion == null) {
        def jreVersionStr  = System.getProperty("java.version");
        def matches        = ( jreVersionStr =~ /^(\d\.\d+)\..*$/ )

        final double jreVer;
        if(matches.matches()) {
            jreVer = Double.parseDouble(matches.group(1));
        } else {
            throw new RuntimeException("Could not determine version from property java.version=" + jreVersionStr);
        }

        return jreVer
    } else {
        return envJreVersion;
    }
}.call()

/************************ jsr308 variables ************************/
def jsr308Dir   = env["JSR308"] ?: file(new File("..")).absolutePath

def jsr308_langtoolsDir = (jsr308Dir + "/jsr308-langtools")

def checkerFrameworkDir = jsr308Dir + "/checker-framework"

def cfInferenceDir = jsr308Dir + "/checker-framework-inference"

// dir of generic type inference solver
def gtisDir = jsr308Dir + "/generic-type-inference-solver"

/************************ util functions ************************/
//Closure that creates a file from a base directory and a name of the file in that directory
def fromBaseDir   = { baseDir, child -> baseDir ? new File(baseDir, child) : new File(child)  }

//A function that, given a file name, creates a file object of that name with
//checkersDir as its parent
def checkerFrameworkChild = fromBaseDir.curry(checkerFrameworkDir)

def cfInferenceChild = fromBaseDir.curry(cfInferenceDir)

/************************ build variables ************************/
//JarsToPackage contains both all members that should be on the classpath for this build
// should use `+` operation at the end of a line which would means "append" in groovy
// http://stackoverflow.com/questions/31044673/groovy-postgres-no-signature-of-method-java-lang-string-positive
def jarsToPackage = [//checker relative paths
                     "checker/dist/checker.jar",
].collect { checkerFrameworkChild(it).getAbsolutePath() } +
        [
                "dist/checker-framework-inference.jar",
        ].collect { cfInferenceChild(it).getAbsolutePath() }

def gtisClasspath = gtisDir+"/bin"

//A list of files to append to the class path during compilation
def toPackageClasspath = files(
        jarsToPackage
                + gtisClasspath
)

/************************ java plugin arguments ************************/
// In this section you declare where to find the dependencies of your project
repositories {
    // Use 'jcenter' for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
    mavenCentral()
}

configurations {
    checkerFrameworkAnnotatedJDK {
        description = 'a copy of JDK classes with Checker Framework type qualifers inserted'
    }
}

// In this section you declare the dependencies for your production and test code
dependencies {
    // solver backend dependencies
    // TODO: should be removed when we get rid of classic solver
    // TODO: currently the runtime dependencies of sat4j is bit tricky --- it actually uses the sat4j from cfi/dist
    //       should we also snapshot a copy of sat4j from mavenCentral into ontology?
    compile 'org.ow2.sat4j:org.ow2.sat4j.core:2.3.4'
    compile 'org.ow2.sat4j:org.ow2.sat4j.maxsat:2.3.4'
    compile group: 'junit', name: 'junit', version: '4.12'
    // The production code uses the SLF4J logging API at compile time
    compile 'org.slf4j:slf4j-api:1.7.13'

    // Declare the dependency for your favourite test framework you want to use in your tests.
    // TestNG is also supported by the Gradle Test task. Just change the
    // testCompile dependency to testCompile 'org.testng:testng:6.8.1' and add
    // 'test.useTestNG()' to your build script.
    testCompile 'junit:junit:3.8.2'

    ext.checkerframeworkdist = "$System.env.CHECKERFRAMEWORK/checker/dist"
    ext.jdkVersion = JavaVersion.current().isJava7() ? 'jdk7' : 'jdk8'
    checkerFrameworkAnnotatedJDK fileTree(dir: "${checkerframeworkdist}", include: "${jdkVersion}.jar")
}

sourceSets {
    main {
        compileClasspath += toPackageClasspath
        resources.srcDirs = ["src/main/java"]
        output.resourcesDir = "build/classes/main"
    }


    test {
        compileClasspath += toPackageClasspath
        runtimeClasspath += compileClasspath
    }
}


//Switch the Javac used to the JSR308
tasks.compileJava {
    description = 'Compiles this project using the jsr308 compiler.'
    options.fork = true
    options.compilerArgs = [
            // This DOES NOT WORK!!!! Why???
            '-Xbootclasspath/p:${configurations.checkerFrameworkAnnotatedJDK.asPath}',
            '-implicit:class',
            '-Awarns', '-Xmaxwarns', '10000']
    println "$configurations.checkerFrameworkAnnotatedJDK.asPath"
    if(jreVersion == 1.7) {
        options.compilerArgs += ['-source' , '7', '-target', '7']
    }
    options.forkOptions.executable="$jsr308_langtoolsDir/dist/bin/javac"
}

tasks.clean {
    delete 'bin', 'dist', 'testTmp', 'annotated',
            fileTree('.') { include '**/*.jaif',  '**/*.txt'},
            fileTree('testinput') {include '**/*.class'}
}

libsDirName="../dist"